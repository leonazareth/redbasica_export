# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RedBasicaExportDockWidget
                                 A QGIS plugin
 Export the sewer network designed using RedBasica to other formats
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-23
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Leonardo Nazareth
        email                : leonazareth@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from typing import Optional

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, QTimer, Qt, QCoreApplication, QVariant
from qgis.PyQt.QtWidgets import QMessageBox, QFileDialog, QInputDialog, QProgressBar, QDialog, QVBoxLayout, QLabel, QComboBox, QDialogButtonBox
from qgis.core import (
    QgsProject, QgsVectorLayer, QgsWkbTypes, QgsMapLayerProxyModel,
    Qgis, QgsMessageLog, QgsSpatialIndex, QgsFeatureRequest, QgsGeometry, NULL, QgsField
)
from qgis.utils import iface
from qgis.gui import QgsMapLayerComboBox

from .core.layer_manager import LayerManager
from .core.data_structures import GeometryType
from .core.template_manager import TemplateManager
from .core.dxf_exporter import DXFExporter
from .core.configuration import Configuration, ExportConfiguration
from .ui.main_export_dialog import MainExportDialog

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'redbasica_export_dockwidget_base.ui'))


class RedBasicaExportDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    """
    Enhanced dockwidget for sewerage network export with integrated controls.
    
    Features:
    - Layer selection shortcuts
    - Quick export options
    - Progress reporting
    - Status updates
    """

    closingPlugin = pyqtSignal()

    def __init__(self, layer_manager: LayerManager, template_manager: TemplateManager, 
                 dxf_exporter: DXFExporter, parent=None):
        """
        Constructor.
        
        Args:
            layer_manager: LayerManager instance
            template_manager: TemplateManager instance
            dxf_exporter: DXFExporter instance
            parent: Parent widget
        """
        super(RedBasicaExportDockWidget, self).__init__(parent)
        
        # Set up the user interface from Designer
        self.setupUi(self)
        
        # Store core components
        self.layer_manager = layer_manager
        self.template_manager = template_manager
        self.dxf_exporter = dxf_exporter
        self.configuration = Configuration()
        
        # Main export dialog
        self.main_export_dialog = None
        
        # Current export configuration
        self.current_config = None
        
        # Setup UI components
        self._setup_ui()
        self._connect_signals()
        self._update_layer_info()
        
        # Timer for delayed updates
        self.update_timer = QTimer()
        self.update_timer.setSingleShot(True)
        self.update_timer.timeout.connect(self._update_layer_info)

    def _setup_ui(self):
        """Set up UI components and layer filtering."""
        # Configure layer combo boxes with geometry filtering
        self.pipesLayerCombo.setFilters(QgsMapLayerProxyModel.LineLayer)
        self.pipesLayerCombo.setAllowEmptyLayer(True)
        self.pipesLayerCombo.setShowCrs(True)
        
        self.junctionsLayerCombo.setFilters(QgsMapLayerProxyModel.PointLayer)
        self.junctionsLayerCombo.setAllowEmptyLayer(True)
        self.junctionsLayerCombo.setShowCrs(True)
        
        # Set initial status
        self.statusLabel.setText("Ready - Select layers to begin")
        
        # Rename button to reflect enhanced functionality
        self.assignNodeIdsButton.setText("Assign Nodes & Attributes")
        self.assignNodeIdsButton.setToolTip("Assign Node IDs, Depth, and Elevation to connected pipes")
        
        # Load last used layers if available
        self._load_last_layer_selection()

    def _connect_signals(self):
        """Connect UI signals to handlers."""
        # Layer selection changes
        self.pipesLayerCombo.layerChanged.connect(self._on_layer_changed)
        self.junctionsLayerCombo.layerChanged.connect(self._on_layer_changed)
        
        # Button clicks
        self.openExportDialogButton.clicked.connect(self._open_export_dialog)
        self.quickExportButton.clicked.connect(self._quick_export)
        self.assignNodeIdsButton.clicked.connect(self._open_node_id_selection_dialog)

    def _on_layer_changed(self):
        """Handle layer selection changes."""
        # Delay update to avoid multiple rapid calls
        self.update_timer.start(500)
        
        # Save layer selection
        self._save_layer_selection()
        
        # Update quick export button state
        self._update_quick_export_button()

    def _update_layer_info(self):
        """Update layer information display."""
        pipes_layer = self.pipesLayerCombo.currentLayer()
        junctions_layer = self.junctionsLayerCombo.currentLayer()
        
        info_lines = []
        
        if pipes_layer:
            pipe_count = pipes_layer.featureCount()
            field_count = len(pipes_layer.fields())
            info_lines.append(f"<b>Pipes:</b> {pipes_layer.name()}")
            info_lines.append(f"  • {pipe_count} features, {field_count} fields")
            
            # Check geometry type
            if pipes_layer.geometryType() != QgsWkbTypes.LineGeometry:
                info_lines.append(f"  • <span style='color: red;'>⚠ Not a line layer</span>")
        
        if junctions_layer:
            junction_count = junctions_layer.featureCount()
            field_count = len(junctions_layer.fields())
            info_lines.append(f"<b>Junctions:</b> {junctions_layer.name()}")
            info_lines.append(f"  • {junction_count} features, {field_count} fields")
            
            # Check geometry type
            if junctions_layer.geometryType() != QgsWkbTypes.PointGeometry:
                info_lines.append(f"  • <span style='color: red;'>⚠ Not a point layer</span>")
        
        if not pipes_layer and not junctions_layer:
            info_lines.append("<span style='color: #666666;'>Select layers to see information</span>")
        
        self.layerInfoText.setHtml("<br>".join(info_lines))

    def _update_quick_export_button(self):
        """Update quick export button state based on available configuration."""
        # Check if we have a saved configuration and at least one layer selected
        has_config = self.configuration.has_export_configuration()
        has_layers = (self.pipesLayerCombo.currentLayer() is not None or 
                     self.junctionsLayerCombo.currentLayer() is not None)
        
        self.quickExportButton.setEnabled(has_config and has_layers)
        
        if has_config and has_layers:
            self.quickExportButton.setToolTip("Export with last used settings")
        elif not has_config:
            self.quickExportButton.setToolTip("No saved export configuration available")
        else:
            self.quickExportButton.setToolTip("Select at least one layer to enable quick export")

    def _open_export_dialog(self):
        """Open the main export configuration dialog."""
        try:
            # Create dialog if needed
            if not self.main_export_dialog:
                self.main_export_dialog = MainExportDialog(
                    layer_manager=self.layer_manager,
                    parent=self
                )
                self.main_export_dialog.export_requested.connect(self._handle_export_request)
            
            # Pre-select layers from dockwidget
            pipes_layer = self.pipesLayerCombo.currentLayer()
            junctions_layer = self.junctionsLayerCombo.currentLayer()
            
            if pipes_layer:
                self.main_export_dialog.pipesLayerCombo.setLayer(pipes_layer)
            if junctions_layer:
                self.main_export_dialog.junctionsLayerCombo.setLayer(junctions_layer)
            
            # Show dialog
            self.main_export_dialog.show()
            self.main_export_dialog.raise_()
            self.main_export_dialog.activateWindow()
            
        except Exception as e:
            QgsMessageLog.logMessage(f"Failed to open export dialog: {e}", "RedBasica Export", Qgis.Critical)
            QMessageBox.critical(self, "Dialog Error", f"Failed to open export dialog:\n{str(e)}")

    def _quick_export(self):
        """Perform quick export with last used settings."""
        try:
            # Load last configuration
            print(f"DEBUG: Quick export - loading configuration")
            config = self.configuration.load_export_configuration()
            print(f"DEBUG: Quick export - loaded config: {config}")
            if config:
                print(f"DEBUG: Quick export - config.pipes_mapping: {config.pipes_mapping}")
                print(f"DEBUG: Quick export - config.junctions_mapping: {config.junctions_mapping}")
            
            if not config:
                QMessageBox.warning(
                    self, "No Configuration",
                    "No saved export configuration found. Please use 'Configure Export...' first."
                )
                return
            
            # Update layer selections from current dockwidget state
            pipes_layer = self.pipesLayerCombo.currentLayer()
            junctions_layer = self.junctionsLayerCombo.currentLayer()
            
            print(f"DEBUG: Quick export - pipes_layer: {pipes_layer}")
            print(f"DEBUG: Quick export - junctions_layer: {junctions_layer}")
            
            # Safety check: if config doesn't have mappings but we have layers, skip quick export
            if pipes_layer and not config.pipes_mapping:
                print(f"DEBUG: Quick export - pipes layer selected but no pipes_mapping in config")
                QMessageBox.warning(
                    self, "Configuration Error",
                    "Configuration is incomplete. Please use 'Configure Export...' to set up field mappings."
                )
                return
            
            if junctions_layer and not config.junctions_mapping:
                print(f"DEBUG: Quick export - junctions layer selected but no junctions_mapping in config")
                QMessageBox.warning(
                    self, "Configuration Error", 
                    "Configuration is incomplete. Please use 'Configure Export...' to set up field mappings."
                )
                return
            
            if pipes_layer and config.pipes_mapping:
                config.pipes_mapping.layer_id = pipes_layer.id()
                config.pipes_mapping.layer_name = pipes_layer.name()
            
            if junctions_layer and config.junctions_mapping:
                config.junctions_mapping.layer_id = junctions_layer.id()
                config.junctions_mapping.layer_name = junctions_layer.name()
            
            # Validate configuration
            if not pipes_layer and not junctions_layer:
                QMessageBox.warning(
                    self, "No Layers Selected",
                    "Please select at least one layer (pipes or junctions) for export."
                )
                return
            
            # Prompt for output file
            last_output = self.configuration.get_setting('last_output_path', '')
            if last_output:
                default_path = last_output
            else:
                project = QgsProject.instance()
                if project.fileName():
                    default_path = os.path.splitext(project.fileName())[0] + "_export.dxf"
                else:
                    default_path = os.path.expanduser("~/sewerage_export.dxf")
            
            output_path, _ = QFileDialog.getSaveFileName(
                self, "Quick Export - Save DXF File",
                default_path, "DXF Files (*.dxf);;All Files (*)"
            )
            
            if not output_path:
                return  # User cancelled
            
            config.output_path = output_path
            
            # Perform export
            config_dict = self.configuration._export_config_to_dict(config)
            self._handle_export_request(config_dict)
            
        except Exception as e:
            QgsMessageLog.logMessage(f"Quick export failed: {e}", "RedBasica Export", Qgis.Critical)
            QMessageBox.critical(self, "Export Error", f"Quick export failed:\n{str(e)}")

    def _handle_export_request(self, config_dict):
        """
        Handle export request and show progress.
        
        Args:
            config_dict: Dictionary containing export configuration
        """
        try:
            # Convert dict back to ExportConfiguration
            config = self.configuration._dict_to_export_config(config_dict)
            
            # Update status and show progress
            self.statusLabel.setText("Exporting...")
            self.progressBar.setVisible(True)
            self.progressBar.setValue(0)
            
            # Disable buttons during export
            self.openExportDialogButton.setEnabled(False)
            self.quickExportButton.setEnabled(False)
            
            # Perform export with progress updates
            success, message, stats = self.dxf_exporter.export_with_error_handling(config)
            
            # Hide progress and re-enable buttons
            self.progressBar.setVisible(False)
            self.openExportDialogButton.setEnabled(True)
            self._update_quick_export_button()
            
            if success:
                self.statusLabel.setText("Export completed successfully")
                QMessageBox.information(
                    self, "Export Complete",
                    f"Sewerage network exported successfully to:\n{config.output_path}\n\n{message}"
                )
                
                # Save configuration for future quick exports
                print(f"DEBUG: About to save configuration in dockwidget")
                print(f"DEBUG: config.pipes_mapping before save: {config.pipes_mapping}")
                print(f"DEBUG: config.junctions_mapping before save: {config.junctions_mapping}")
                save_result = self.configuration.save_export_configuration(config)
                print(f"DEBUG: Configuration save result: {save_result}")
                self.configuration.set_setting('last_output_path', config.output_path)
                
            else:
                self.statusLabel.setText("Export failed")
                QMessageBox.critical(
                    self, "Export Failed",
                    f"Failed to export sewerage network:\n{message}"
                )
                
        except Exception as e:
            # Hide progress and re-enable buttons
            self.progressBar.setVisible(False)
            self.openExportDialogButton.setEnabled(True)
            self._update_quick_export_button()
            
            self.statusLabel.setText("Export error")
            QgsMessageLog.logMessage(f"Export error: {e}", "RedBasica Export", Qgis.Critical)
            QMessageBox.critical(
                self, "Export Error",
                f"An unexpected error occurred during export:\n{str(e)}"
            )

    def _load_last_layer_selection(self):
        """Load last used layer selections."""
        try:
            pipes_layer_id = self.configuration.get_setting('last_pipes_layer_id', '')
            junctions_layer_id = self.configuration.get_setting('last_junctions_layer_id', '')
            
            if pipes_layer_id:
                layer = QgsProject.instance().mapLayer(pipes_layer_id)
                if layer and isinstance(layer, QgsVectorLayer):
                    self.pipesLayerCombo.setLayer(layer)
            
            if junctions_layer_id:
                layer = QgsProject.instance().mapLayer(junctions_layer_id)
                if layer and isinstance(layer, QgsVectorLayer):
                    self.junctionsLayerCombo.setLayer(layer)
                    
        except Exception:
            # If loading fails, continue with empty selection
            pass

    def _save_layer_selection(self):
        """Save current layer selections."""
        try:
            pipes_layer = self.pipesLayerCombo.currentLayer()
            junctions_layer = self.junctionsLayerCombo.currentLayer()
            
            pipes_id = pipes_layer.id() if pipes_layer else ''
            junctions_id = junctions_layer.id() if junctions_layer else ''
            
            self.configuration.set_setting('last_pipes_layer_id', pipes_id)
            self.configuration.set_setting('last_junctions_layer_id', junctions_id)
            
        except Exception:
            # If saving fails, continue silently
            pass

    def _open_node_id_selection_dialog(self):
        """Open dialog to select Node ID, Depth, and Elevation fields."""
        pipes_layer = self.pipesLayerCombo.currentLayer()
        junctions_layer = self.junctionsLayerCombo.currentLayer()

        if not pipes_layer or not junctions_layer:
            QMessageBox.warning(
                self, "Missing Layers",
                "Please select both Pipes and Junctions layers first."
            )
            return

        # Get fields from junctions layer
        fields = [f.name() for f in junctions_layer.fields()]
        
        # Custom Dialog for multiple field selection
        dialog = NodeAssignmentDialog(fields, parent=self)
        if dialog.exec_() == QDialog.Accepted:
            node_id_field, depth_field, elev_field = dialog.get_selected_fields()
            self._execute_node_assignment(node_id_field, depth_field, elev_field)

    def _execute_node_assignment(self, node_id_field, depth_field=None, elev_field=None):
        """
        Execute the spatial assignment of Node attributes to pipes.
        
        Args:
            node_id_field (str): Name of the ID field in junctions layer
            depth_field (str): Name of depth field (optional)
            elev_field (str): Name of elevation field (optional)
        """
        pipes_layer = self.pipesLayerCombo.currentLayer()
        junctions_layer = self.junctionsLayerCombo.currentLayer()
        
        if not pipes_layer.isEditable():
            pipes_layer.startEditing()
            
        try:
            # Create progress widget (MessageBar best practice)
            progressMessage = iface.messageBar().createMessage("Assigning Node IDs...")
            progressBar = QProgressBar()
            progressBar.setMaximum(pipes_layer.featureCount())
            progressBar.setAlignment(Qt.AlignLeft|Qt.AlignVCenter)
            progressMessage.layout().addWidget(progressBar)
            iface.messageBar().pushWidget(progressMessage, Qgis.Info)

            # Ensure fields exist
            fields_to_add = []
            
            # Map of fields to create -> Type
            new_fields = {
                'p1_id': QVariant.String,
                'p2_id': QVariant.String,
                'p1_h': QVariant.Double,
                'p2_h': QVariant.Double,
                'p1_elev': QVariant.Double,
                'p2_elev': QVariant.Double
            }
            
            for field_name, field_type in new_fields.items():
                if pipes_layer.fields().indexFromName(field_name) == -1:
                    fields_to_add.append(QgsField(field_name, field_type))
                
            if fields_to_add:
                pipes_layer.dataProvider().addAttributes(fields_to_add)
                pipes_layer.updateFields()

            # Get field indices
            idx_map = {
                'p1_id': pipes_layer.fields().indexFromName('p1_id'),
                'p2_id': pipes_layer.fields().indexFromName('p2_id'),
                'p1_h': pipes_layer.fields().indexFromName('p1_h'),
                'p2_h': pipes_layer.fields().indexFromName('p2_h'),
                'p1_elev': pipes_layer.fields().indexFromName('p1_elev'),
                'p2_elev': pipes_layer.fields().indexFromName('p2_elev')
            }

            # Build Spatial Index
            index = QgsSpatialIndex(junctions_layer.getFeatures())
            
            # Cache junction attributes map {feature_id: {field: value}}
            # This avoids re-querying the layer constantly
            junction_cache = {}
            for j_feat in junctions_layer.getFeatures():
                data = {'id': j_feat[node_id_field]}
                if depth_field:
                    data['h'] = j_feat[depth_field]
                if elev_field:
                    data['elev'] = j_feat[elev_field]
                junction_cache[j_feat.id()] = data

            count = 0
            assignments = 0
            pipes_with_issues = 0
            
            for p_feat in pipes_layer.getFeatures():
                progressBar.setValue(count)
                QCoreApplication.processEvents() # Needed for UI updates since we dominate the main thread
                    
                geom = p_feat.geometry()
                if not geom or geom.isEmpty():
                    count += 1
                    continue
                    
                # Get start and end points
                if geom.isMultipart():
                    points = geom.asMultiPolyline()[0]
                else:
                    points = geom.asPolyline()
                    
                start_pt = points[0]
                end_pt = points[-1]
                
                has_missing_node = False
                
                # Search Upstream (Start Point)
                upstream_ids = index.nearestNeighbor(start_pt, 1)
                found_upstream = False
                if upstream_ids:
                    u_feat_id = upstream_ids[0]
                    u_data = junction_cache.get(u_feat_id, {})
                    
                    pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p1_id'], u_data.get('id', NULL))
                    if depth_field:
                        pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p1_h'], u_data.get('h', NULL))
                    if elev_field:
                        pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p1_elev'], u_data.get('elev', NULL))
                        
                    found_upstream = True
                else:
                    pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p1_id'], NULL)
                    # Clear other fields if no node found (optional but cleaner)
                    if depth_field: pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p1_h'], NULL)
                    if elev_field: pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p1_elev'], NULL)
                    has_missing_node = True

                # Search Downstream (End Point)
                downstream_ids = index.nearestNeighbor(end_pt, 1)
                found_downstream = False
                if downstream_ids:
                    d_feat_id = downstream_ids[0]
                    d_data = junction_cache.get(d_feat_id, {})
                    
                    pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p2_id'], d_data.get('id', NULL))
                    if depth_field:
                        pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p2_h'], d_data.get('h', NULL))
                    if elev_field:
                        pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p2_elev'], d_data.get('elev', NULL))
                        
                    found_downstream = True
                else:
                    pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p2_id'], NULL)
                    if depth_field: pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p2_h'], NULL)
                    if elev_field: pipes_layer.changeAttributeValue(p_feat.id(), idx_map['p2_elev'], NULL)
                    has_missing_node = True
                
                if found_upstream and found_downstream:
                    assignments += 1
                
                if has_missing_node:
                    pipes_with_issues += 1

                count += 1
                
            # Clear progress widget
            iface.messageBar().popWidget(progressMessage)

            # Atomic Save
            if pipes_layer.commitChanges():
                if pipes_with_issues == 0:
                    iface.messageBar().pushMessage(
                        "Node Assignment Success",
                        f"All {assignments} pipes were successfully connected to upstream and downstream nodes.",
                        level=Qgis.Success, duration=5
                    )
                else:
                    iface.messageBar().pushMessage(
                        "Node Assignment Warning",
                        f"Assigned IDs to {assignments} fully connected pipes. <br><b>Warning:</b> {pipes_with_issues} pipes have missing start or end nodes (NULL values). Check topology.",
                        level=Qgis.Warning, duration=10
                    )
            else:
                iface.messageBar().pushMessage(
                    "Save Error",
                    f"Failed to save changes: {pipes_layer.commitErrors()}",
                    level=Qgis.Critical, duration=10
                )
                
        except Exception as e:
            pipes_layer.rollBack()
            # Clear progress widget if it exists
            if 'progressMessage' in locals():
                iface.messageBar().popWidget(progressMessage)
                
            iface.messageBar().pushMessage(
                "Execution Error",
                f"An error occurred: {str(e)}",
                level=Qgis.Critical, duration=10
            )
            QgsMessageLog.logMessage(str(e), "RedBasica Export", Qgis.Critical)


class NodeAssignmentDialog(QDialog):
    """Dialog to select attributes for Node Assignment."""
    
    def __init__(self, fields, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Assign Nodes & Attributes")
        
        layout = QVBoxLayout(self)
        layout.setSizeConstraint(QVBoxLayout.SetFixedSize)  # Minimize size to content
        
        # ID Field
        layout.addWidget(QLabel("Node ID Field (Required):"))
        self.id_combo = QComboBox()
        self.id_combo.addItems(fields)
        self._set_default(self.id_combo, ["id_nodo_(n", "node_id", "id"])
        layout.addWidget(self.id_combo)
        
        # Depth Field
        layout.addWidget(QLabel("Node Depth Field (h):"))
        self.depth_combo = QComboBox()
        self.depth_combo.addItem(" - Skip - ", None)
        self.depth_combo.addItems(fields)
        self._set_default(self.depth_combo, ["h_nodo_nt", "depth", "profundidade"])
        layout.addWidget(self.depth_combo)
        
        # Elevation Field
        layout.addWidget(QLabel("Node Elevation Field (Terrain/Cover):"))
        self.elev_combo = QComboBox()
        self.elev_combo.addItem(" - Skip - ", None)
        self.elev_combo.addItems(fields)
        self._set_default(self.elev_combo, ["ct_(n)", "elev", "cota"])
        layout.addWidget(self.elev_combo)
        
        # Buttons
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
    def _set_default(self, combo, candidates):
        """Select first matching candidate based on priority."""
        for cand in candidates:
            cand = cand.lower()
            for i in range(combo.count()):
                text = combo.itemText(i).lower()
                if cand in text: # flexible matching
                    combo.setCurrentIndex(i)
                    return

    def get_selected_fields(self):
        """Return (id_field, depth_field, elev_field)."""
        id_f = self.id_combo.currentText()
        
        depth_f = self.depth_combo.currentText()
        if depth_f == " - Skip - ": depth_f = None
        
        elev_f = self.elev_combo.currentText()
        if elev_f == " - Skip - ": elev_f = None
        
        return id_f, depth_f, elev_f

